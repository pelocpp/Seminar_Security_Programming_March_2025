// =========================================

Seminar Sicherheitsprogrammierung in C / C++

Peter Loos

C/C++, Java, C#,  Mobile Programming (Java),
Kotlin, 

Technik Akademie Erlangen  

// Informatik
// Automatisierung

Python

Back-to-the-Roots: C/C++

Guten Morgen

Vormittags & Nachmittags

12.30 - 13.30

// =========================================

Cache Line

Sanitizer

Type - Conversion

WEITERARBEIT:

STL:  Container, Algorithmen

MT / Parallele Algorithmen.

"no-naked for-loop"

Performanz

Assembler // Eleganz


===========================================

2 Tools:

a) Github

https://github.com/pelocpp

https://github.com/pelocpp/cpp_clean_performant_secure_code

b) Visual Studio

// =========================================

Was soll denn drin sein ???

Was sind meine Erwartungen ????

// =========================================

Maschinencode

Zuverlässigkeit

C / C++

"Pointer auf Vektor Element"

Pointer:  Non-Owning Zeiger

// =========================================

C ist in C++ echt enthalten !!! Zu 99%.

C++: Verwende ich alles von C in C++: Nein.

Beispiel: Parameterübergabe:  C++: Via Referenz
                                   Not: Via Pointer

NICHT: Ist der Pointer obsolet in C++: new / delete

C++: Templates.  Sind ein Stellvertreter für einen realen Datentyp.

NICHTS dynamisches dabei .

C# / Java:

2 Phasen-Übersetzung:

1. Phase: C# => Zwischencode.

Virtualle Maschine: SW : Die führt den Zwischencode aus.

                        Zusätzlichen Funktionalität: Speicherverwaltung 

                        new, new, new // kein delete: Garbage Collector

2. Phase: Zwischencode => Maschinecode.

// ========================================

new versus not new:

Wo liegen Objekte:

new ===> HEAP !!!!!!!!

no new ===>  STACK !!!!!!!!
no new ===>  GLOBALES DATENSEGMENT !!!!!!!! Destruktor wird nach Verlassen von main aufgerufen.

       Es können in den Instanzvariablen Daten auf dem Heap angelegt werden.

       Nicht negativ: Auch der Stack hat seine Grenzen.

       No Heap: Embedded Programming: Jepp, das gibt es.

       räumt sich selber auf !!!  Schließende }: Destruktor

Was ist nicht so positiv an new:  a) delete b) Performanz.

==============================================================

C ist eine High-Level Language:

Jepp, durchaus, wenn man mit Assembler vergleicht.

==============================================================

Undefined Behaviour (UB)

C++:

int* ip = new int;                delete ip;          Scalar-new // Scalar - delete

int* ip = new int[10];            delete[] ip;        Array-new // Array - delete

Wenn ich im zweiten Fall "delete ip" verwenden würde: NICHT DEFINIERT.

                                  Undefined Behaviour // UB

Undefined Behaviour gibt es in C++ an sehr vielen Stellen.

// =================================================================

AX:   16 Bit Welt

EAX:  32 Bit Welt   // e = extended



xor         eax,eax    Da wird einfach 0 in den Akku geschrieben


EAX
EBX
EXC
EDX


Für den Stack gibt es 2 Register:

SP

BP   Base Pointer

======================================================

++i oder i++   :-)))

Steht ++i oder i++ isoliert da, gibt es keinen Unterschied.

int n = ++i;

int n = i++;

===========================================================

Speicher, der NiCHT vorbelegt ist:

Ist dennoch vorbelegt: 

Debug-Modus:

Stack: CC
Heap:  CD

Heap:  DD, nach der Freigabe mit einem ungültigen Zeiger

==============================================================

Typ - Konversion:

a) C-Style Cast

b) C++ - Style Casting: Named Casting // static_cast, const_cast , ...

=================================================================

Wandbox:

Compiler Explorer // God Bolt // Assembler-lastig

https://wandbox.org/

Online-Compiler

=======================================================================

Array Decay:  to decay ==> verkümmern  // Verlust

Java, C#: Ein Array in Java, C#, JavaScript hat eine Länge.

C/C++: Ein Array in C/C++ hat eine Länge.

C/C++: Ein Adresse in C/C++ (auch wenn dieses auf ein Feld zeigt) hat KEINE Länge.



=======================================================================

C/C++ hat in der Durchgängigkeit bei der Parameterübergabe
eine extreme Inkonsistenz:

Call-by-Value:    // Kopien

int n = 123;  
func (n);         n ist eine Kopie // könnte auch in einem Register übergeben werden.

int* ip = ages[0];
func (ip);        ip ist eine Kopie 

Felder werden als ADRESSE (erstes Element) übergeben.

Strukturen:

Strukturen werden als KOPIE übergeben.

=========================================================================

Referenzen:

Wozu / warum wurden Referenzen in C++ ergänzt?

a) Einfachere Syntax

b) Es gibt keine NULL-Referenzen.

c) Wann / bei welchen Variablen werden Referenzen am meisten verwendet // sie nicht verwendet:

i)  Große Variablen / Objekt
ii) Sie werden vorzugsweise verwendet

    == bei Stack-Variablen
    == bei Globalen Variablen

    (( Heap: new ===> Zeiger / Pointer))  // Man kann auch eine Referenz auf ein Objekt am Heap stellen.
    Aber wie lange ist diese Referenz dann gültig ????

    
================================================

Dangling Referenz:


================================================

Copy - Elision:

Copy / Move Elision:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/CopyMoveElision/CopyMoveElision.md

================================================

std::println  //  Ab C++ 23 // 

The return of C-printf : Thanks God :-)

Wahrheit: println von C# // Python

================================================

Beobachtung:

Performanz:

Debug:    2000 // 4000 
Release:  0 / 0

================================================

