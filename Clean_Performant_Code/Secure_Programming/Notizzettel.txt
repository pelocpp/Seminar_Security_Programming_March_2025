// =========================================

Seminar Sicherheitsprogrammierung in C / C++

Peter Loos

C/C++, Java, C#,  Mobile Programming (Java),
Kotlin, 

Technik Akademie Erlangen  

// Informatik
// Automatisierung

Python

Back-to-the-Roots: C/C++

Guten Morgen

Vormittags & Nachmittags

12.30 - 13.30

// =========================================

To be Dones:

Cache Line
Sanitizer
Type - Conversion

STL:  Container, Algorithmen
MT / Parallele Algorithmen.

"no-naked for-loop"
Performanz
Assembler // Eleganz

RAII
Smart Pointer
auto: Ein Beispiel
Exception Handling
Verwende nur Named Casts bzw. New-Style-Casts zur Typkonvertierung // C++ casts zB static_cast

Ranges Bibliothek // 15 Minutes

===========================================

Frage:

https://stackoverflow.com/questions/60419126/why-does-vs-debug-build-allocates-variables-so-far-apart

Warum liegen die Variablen soweit auseinander ????

==============================================

2 Tools:

a) Github

https://github.com/pelocpp

https://github.com/pelocpp/cpp_clean_performant_secure_code

b) Visual Studio

// =========================================

Was soll denn drin sein ???

Was sind meine Erwartungen ????

// =========================================

Maschinencode

Zuverlässigkeit

C / C++

"Pointer auf Vektor Element"

Pointer:  Non-Owning Zeiger

// =========================================

C ist in C++ echt enthalten !!! Zu 99%.

C++: Verwende ich alles von C in C++: Nein.

Beispiel: Parameterübergabe:  C++: Via Referenz
                                   Not: Via Pointer

NICHT: Ist der Pointer obsolet in C++: new / delete

C++: Templates.  Sind ein Stellvertreter für einen realen Datentyp.

NICHTS dynamisches dabei .

C# / Java:

2 Phasen-Übersetzung:

1. Phase: C# => Zwischencode.

Virtualle Maschine: SW : Die führt den Zwischencode aus.

                        Zusätzlichen Funktionalität: Speicherverwaltung 

                        new, new, new // kein delete: Garbage Collector

2. Phase: Zwischencode => Maschinecode.

// ========================================

new versus not new:

Wo liegen Objekte:

new ===> HEAP !!!!!!!!

no new ===>  STACK !!!!!!!!
no new ===>  GLOBALES DATENSEGMENT !!!!!!!! Destruktor wird nach Verlassen von main aufgerufen.

       Es können in den Instanzvariablen Daten auf dem Heap angelegt werden.

       Nicht negativ: Auch der Stack hat seine Grenzen.

       No Heap: Embedded Programming: Jepp, das gibt es.

       räumt sich selber auf !!!  Schließende }: Destruktor

Was ist nicht so positiv an new:  a) delete b) Performanz.

==============================================================

C ist eine High-Level Language:

Jepp, durchaus, wenn man mit Assembler vergleicht.

==============================================================

Undefined Behaviour (UB)

C++:

int* ip = new int;                delete ip;          Scalar-new // Scalar - delete

int* ip = new int[10];            delete[] ip;        Array-new // Array - delete

Wenn ich im zweiten Fall "delete ip" verwenden würde: NICHT DEFINIERT.

                                  Undefined Behaviour // UB

Undefined Behaviour gibt es in C++ an sehr vielen Stellen.

// =================================================================

AX:   16 Bit Welt

EAX:  32 Bit Welt   // e = extended



xor         eax,eax    Da wird einfach 0 in den Akku geschrieben


EAX
EBX
EXC
EDX


Für den Stack gibt es 2 Register:

SP

BP   Base Pointer

======================================================

++i oder i++   :-)))

Steht ++i oder i++ isoliert da, gibt es keinen Unterschied.

int n = ++i;

int n = i++;

===========================================================

Speicher, der NiCHT vorbelegt ist:

Ist dennoch vorbelegt: 

Debug-Modus:

Stack: CC
Heap:  CD

Heap:  DD, nach der Freigabe mit einem ungültigen Zeiger

==============================================================

Typ - Konversion:

a) C-Style Cast

b) C++ - Style Casting: Named Casting // static_cast, const_cast , ...

=================================================================

Wandbox:

Compiler Explorer // God Bolt // Assembler-lastig

https://wandbox.org/

Online-Compiler

=======================================================================

Array Decay:  to decay ==> verkümmern  // Verlust

Java, C#: Ein Array in Java, C#, JavaScript hat eine Länge.

C/C++: Ein Array in C/C++ hat eine Länge.

C/C++: Ein Adresse in C/C++ (auch wenn dieses auf ein Feld zeigt) hat KEINE Länge.



=======================================================================

C/C++ hat in der Durchgängigkeit bei der Parameterübergabe
eine extreme Inkonsistenz:

Call-by-Value:    // Kopien

int n = 123;  
func (n);         n ist eine Kopie // könnte auch in einem Register übergeben werden.

int* ip = ages[0];
func (ip);        ip ist eine Kopie 

Felder werden als ADRESSE (erstes Element) übergeben.

Strukturen:

Strukturen werden als KOPIE übergeben.

=========================================================================

Referenzen:

Wozu / warum wurden Referenzen in C++ ergänzt?

a) Einfachere Syntax

b) Es gibt keine NULL-Referenzen.

c) Wann / bei welchen Variablen werden Referenzen am meisten verwendet // sie nicht verwendet:

i)  Große Variablen / Objekt
ii) Sie werden vorzugsweise verwendet

    == bei Stack-Variablen
    == bei Globalen Variablen

    (( Heap: new ===> Zeiger / Pointer))  // Man kann auch eine Referenz auf ein Objekt am Heap stellen.
    Aber wie lange ist diese Referenz dann gültig ????

    
================================================

Dangling Referenz:


================================================

Copy - Elision:

Copy / Move Elision:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/CopyMoveElision/CopyMoveElision.md

================================================

std::println  //  Ab C++ 23 // 

The return of C-printf : Thanks God :-)

Wahrheit: println von C# // Python

================================================

Beobachtung:

Performanz:

Debug:    2000 // 4000 
Release:  0 / 0

================================================

a + b < a

b < 0

a+b  versus  MAXIMUM

Ziel: 

a + b <= Maximum

a <= Maximum - b

b <= Maximum - a


Problem: 

a + b > Maximum

a > Maximum - b   // Maximum - b < a

b > Maximum - a   // Maximum - a < b


// ===========================================

"return"-Code Developer

std::optional : 1 Kandidat

std::pair<bool, std::uint32_t>

bool: Hat geklappt oder nicht 
std::uint32_t: Ergebnis, wenn es geklappt hat // 0 

[[nodiscard]] std::pair<bool, std::uint32_t> berechneWas (int , int)
{
    return { false, 0 };
}

void main()
{
    auto [ hatGeklappt, ergebnis ] = berechneWas (1, 2);   //  WARNING: Ergebnis wird nicht abgeholt
}

// =====================================================================

a - b >= MIN_INT



Problem: 

a - b < MIN_INT

a < MIN_INT + b

// - b < MIN_INT - a:  NOPE

a < MIN_INT + b   : klar

Was ist, wenn b kleiner Null ist:

a - b < MIN_INT

a + b1 > MAX_INT



Quellcode: a > MIN_INT + b

a - b < MIN_INT

// =====================================================

Ranges Bibliothek // Standard

// =====================================================

Technik Akademie Erlangen:

C
C++  // (Java) C#
Python // JavaScript

// =====================================================

// C++:

SomeClass anObject;    // Stack // Global

// C# / Java

SomeClass anObject;    // Namen // Referenz (Platz für einen Adresse)

anObject = new SomeClass (...);

oder

SomeClass anObject = new SomeClass (...);
// kein delete: Garbage Collector

C++:

SomeClass* anObject = new SomeClass (...);
..
delete anObject;

Java:

void func()
{
    SomeClass anObject;  // Referenz
    ....
}

// ================================================

Konstruktoren mit einem Argument:

Konvertierungs-Konstruktoren